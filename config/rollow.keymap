// Copyright (c) 2022 The ZMK Contributors
// SPDX-License-Identifier: MIT

#include "../zmk-nodefree-config/helper.h"
#include "../zmk-nodefree-config/keypos_def/keypos_36keys.h"
#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>

#define XXX &none
#define TODO XXX
#define ___ &trans

#define BASE 0
#define NUM 1
#define SYM 2
#define UTIL 3

#define S_UNDO &kp C_AC_UNDO
#define S_CUT &kp C_AC_CUT
#define S_COPY &kp C_AC_COPY
#define S_PASTE &kp C_AC_PASTE
#define S_REDO &kp C_AC_REDO

// TODO:
// - Encoders:
//   - fix right encoder
// - Fix left OLED
// - Fix sticky keys for cadding (use the wrapping around behavior)
// - Layer features
//   - Fn layer
// - Add num+fn+left hand BT switcher
// - Consider HRM
// - Consider mouse layer
// - Triple tap num lock

&sk {  // sticky-key config
    release-after-ms = <2000>;  // release after timeout
    quick-release;             // no double capitalization when rolling keys
};

&sl {  // sticky-layer config
    ignore-modifiers;          // allow chording sticky mods & layers
};

&caps_word {  // mods deactivate caps-word, requires PR #1451
    /delete-property/ ignore-modifiers;
    /delete-property/ ignore-numbers;
    continue-list = <BACKSPACE ENTER DELETE UNDERSCORE MINUS F24>;
};

&num_word {  // num-word, requires PR #1441
    layers = <NUM>;
    continue-list = <BACKSPACE ENTER DELETE UNDERSCORE MINUS PLUS ASTRK EQUAL FSLH DOT LPAR RPAR HASH DLLR PRCNT CARET LEFT RIGHT UP DOWN F24>;
};

&key_repeat {
    usage-pages = <HID_USAGE_KEY HID_USAGE_CONSUMER>;
    ignore-keycodes = <F24>; // requires custom patch
};

/ {
    chosen {
        zmk,matrix_transform = &five_column_transform;
    };

    behaviors {
        // tap: sticky-shift | shift + tap/ double-tap: caps-word | hold: shift
        #define SMRT_SHFT &smrt_shft
        smrt_shft: smrt_shft { 
            compatible = "zmk,behavior-mod-morph";
            label = "SMRT_SHFT";  
            #binding-cells = <0>; 
            bindings = <&sk LSHFT>, <&caps_word>; 
            mods = <(MOD_LSFT)>; 
        }; 
        
        // tap: num-word | double-tap: sticky num-layer | hold: num-layer
        // TODO: need cancel
        #define SMRT_NUM &smrt_num NUM 0
        smrt_num: smrt_num { 
            compatible = "zmk,behavior-hold-tap"; 
            label = "SMRT_NUM";
            #binding-cells = <2>; 
            flavor = "balanced"; 
            tapping-term-ms = <200>; 
            quick-tap-ms = <175>; 
            bindings = <&mo>, 
            <&num_dance>; 
        }; 

       num_dance: num_dance { 
            compatible = "zmk,behavior-tap-dance"; 
            label = "SMRT_NUM_DANCE";
            #binding-cells = <0>; 
            tapping-term-ms = <300>; 
            bindings = <&sl NUM>, <&num_word>; // reverse this for sticky-num on single tap
        };
        
        // Alt+Tab swapper, requires PR #1366
        swapper: swapper { 
            compatible = "zmk,behavior-tri-state"; 
            label = "SWAPPER"; 
            #binding-cells = <0>; 
            bindings 
                = <&kt LALT>
                , <&kp TAB>
                , <&kt LALT>
                ; 
            ignored-key-positions = <LM1>; // shift-alt-tab 
        };
    };

    conditional_layers {
        compatible = "zmk,conditional-layers";
        util_layer {
            if-layers = <NUM SYM>;
            then-layer = <UTIL>;
        };
    };

    macros {
        // when the momentary layer is tapped, cancel any pending OS mods
        // workaround for https://github.com/zmkfirmware/zmk/issues/834
        // the reason this is instead of mo_with_tap is that mo_with_tap has a bug with combos
        mo_sym: mo_sym {
            label = "MO_SYM";
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            wait-ms = <0>;
            tap-ms = <0>;
            bindings
                = <&macro_tap &kp F24>
                , <&macro_press &mo SYM>
                , <&macro_pause_for_release>
                , <&macro_release &mo SYM>
                ;
        };
        mo_num: mo_num {
            label = "MO_NUM";
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            wait-ms = <0>;
            tap-ms = <0>;
            bindings
                = <&macro_tap &kp F24>
                , <&macro_press &mo NUM>
                , <&macro_pause_for_release>
                , <&macro_release &mo NUM>
                ;
        };
    };
    
    keymap {
        compatible = "zmk,keymap";
        default_layer {
            bindings = <
            &kp B   &kp L   &kp D   &kp W    &kp Z       &kp APOS    &kp F    &kp O         &kp U       &kp J 
            &kp N   &kp R   &kp T   &kp S    &kp G       &kp Y       &kp H    &kp A         &kp E       &kp I 
            &kp Q   &kp X   &kp M   &kp C    &kp V       &kp K       &kp P    &comma_morph  &dot_morph  &qmark_morph
                    &kp C_MUTE      SMRT_NUM SMRT_SHFT   &spc_morph  &mo_sym  XXX 
            >;
            sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp UP DOWN>;
        };
        num_layer {
            bindings = <
            &swapper  &kp HASH  &kp DLLR   &kp PRCNT  &kp CARET   &kp PLUS  &kp N7   &kp N8  &kp N9  &kp ASTRK 
            &sk LGUI  &sk LALT  &sk LCTRL  &sk LSHFT  &kp LGUI    &kp N3    &kp N0   &kp N1  &kp N2  &kp EQUAL 
            S_UNDO    S_CUT     S_COPY     S_PASTE    S_REDO      &kp MINUS &kp N4   &kp N5  &kp N6  &kp FSLH 
                                XXX        &mo NUM    &kp SPACE   &kp SPACE &mo SYM  XXX 
            >;
            sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp UP DOWN>;
        };
        sym_layer {
            bindings = <
            &kp TILDE  &kp PIPE  &kp UNDER  &kp LBKT  &kp RBKT   &kp HOME    &kp PG_DN  &kp PG_UP  &kp END    &kp ESC 
            &kp GRAVE  &kp AMPS  &kp AT     &kp LPAR  &kp RPAR   &kp LEFT    &kp DOWN   &kp UP     &kp RIGHT  &kp ENTER 
            &kp BSLH   &kp LT    &kp GT     &kp LBRC  &kp RBRC   &key_repeat &kp BSPC   &kp DEL    &kp TAB    &kp CAPS 
                                 XXX        &mo NUM   ___        ___         &mo SYM    XXX 
            >;
            sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp UP DOWN>;
        };
 
        util_layer {
            bindings = <
            &bootloader XXX       XXX        XXX       &kp PSCRN   &kp HOME     &kp PG_DN  &kp PG_UP   &kp END    &kp ESC 
            &sk LGUI    &sk LALT  &sk LCTRL  &sk LSHFT &kp LGUI    &kp LEFT     &kp DOWN   &kp UP      &kp RIGHT  &kp ENTER 
            S_UNDO      S_CUT     S_COPY     S_PASTE   S_REDO      &key_repeat  &kp BSPC   &kp DEL     &kp TAB    &kp CAPS 
                                  XXX        ___       ___         ___          ___        XXX 
            >;
            sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp UP DOWN>;
        };
    };
};
    
// MOD_MORPHS
// tap: comma | shift + tap: semicolon 
ZMK_BEHAVIOR(comma_morph, mod_morph,
    mods = <(MOD_LSFT|MOD_RSFT)>;
    bindings = <&kp COMMA>, <&kp SEMICOLON>;
)
// tap: dot | shift + tap: colon 
ZMK_BEHAVIOR(dot_morph, mod_morph,
    bindings = <&kp DOT>, <&kp COLON>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
)
// tap: qmark | shift + tap: excl
ZMK_BEHAVIOR(qmark_morph, mod_morph,
    bindings = <&kp QMARK>, <&kp EXCL>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
)

// tap: space | shift + tap: dot -> space -> sticky shift
// triggers on LSHFT but emits RSHFT so that it does not trigger in a loop
ZMK_BEHAVIOR(spc_morph, mod_morph,
    bindings = <&kp SPACE>, <&dot_spc>;
    mods = <(MOD_LSFT)>;
)
ZMK_BEHAVIOR(dot_spc, macro,
    wait-ms = <5>;
    tap-ms = <5>;
    bindings = <&kp DOT &kp SPACE &sk RSHFT>;
)

// COMBOS
// ╭─────────────────────┬─────────────────────╮
// │ LT4 LT3 LT2 LT1 LT0 │ RT0 RT1 RT2 RT3 RT4 │
// │ LM4 LM3 LM2 LM1 LM0 │ RM0 RM1 RM2 RM3 RM4 │
// │ LB4 LB3 LB2 LB1 LB0 │ RB0 RB1 RB2 RB3 RB4 │
// ╰───────╮ LH2 LH1 LH0 │ RH0 RH1 RH2 ╭───────╯
//         ╰─────────────┴─────────────╯
// use global-quick-tap-ms for combos (requires PR 1387)
#undef COMBO_HOOK
#define COMBO_HOOK global-quick-tap-ms = <150>;
// combos on every layer
#define GLOBAL_COMBO(name, keypos, bindings) ZMK_COMBO(name, bindings, keypos, ALL, 30)
GLOBAL_COMBO(esc, LT3 LT2, &kp ESC)
GLOBAL_COMBO(tab, LT2 LT1, &kp TAB)
GLOBAL_COMBO(rep, LB3 LB2, &key_repeat)
GLOBAL_COMBO(ent, LB2 LB1, &kp ENTER)
GLOBAL_COMBO(bksp, RB1 RB2, &kp BSPC)
GLOBAL_COMBO(del, RB2 RB3, &kp DEL)
GLOBAL_COMBO(numl, RB3 RB4, &num_word)

// combos on the numpad
#define NUM_COMBO(name, keypos, bindings) ZMK_COMBO(name, bindings, keypos, NUM, 30)
NUM_COMBO(lpar, RT1 RT2, &kp LPAR)
NUM_COMBO(rpar, RT2 RT3, &kp RPAR)
NUM_COMBO(dot, RM1 RM2, &kp DOT)

// thumb combos are a feature that I designed to make it faster to type keys on the layers
// it allows you to mash the thumb mo key and the key on the layer together at the same time
// it relies on a patch I made to zmk which allows partial-holds when releasing the key while holding the thumb
// thumb combos are implemented using a few hacks that solve all edge cases
// the macro is used to enable the layer while the combo is held so that other keys on the layer can be used
#define THUMB_COMBO(thumb_layer, thumb, keypos, combo_bindings, combo_layers) \
    ZMK_BEHAVIOR(macro_thumb_##thumb_layer##_##thumb##_##keypos, macro, \
        wait-ms = <0>; \
        tap-ms = <0>; \
        bindings \
            = <&macro_press &mo thumb_layer> \
            , <&macro_press combo_bindings> \
            , <&macro_pause_for_release> \
            , <&macro_release combo_bindings> \
            , <&macro_release &mo thumb_layer> \
            ; \
    ) \
    / { \
        combos { \
            compatible = "zmk,combos"; \
            combo_thumb_##thumb_layer##_##thumb##_##keypos { \
                timeout-ms = <40>; \
                key-positions = <thumb keypos>; \
                bindings = <&macro_thumb_##thumb_layer##_##thumb##_##keypos>; \
                partial-holds = <thumb>; \
                layers = <combo_layers>; \
                COMBO_HOOK \
            }; \
        }; \
    };

// right thumb combos with right hand SYM layer
#define SYM_THUMB_COMBO(keypos, bindings) THUMB_COMBO(SYM, RH1, keypos, bindings, BASE NUM)
SYM_THUMB_COMBO(RT0, &kp HOME)
SYM_THUMB_COMBO(RT1, &kp PG_DN)
SYM_THUMB_COMBO(RT2, &kp PG_UP)
SYM_THUMB_COMBO(RT3, &kp END)
SYM_THUMB_COMBO(RT4, &kp ESC)
SYM_THUMB_COMBO(RM0, &kp LEFT)
SYM_THUMB_COMBO(RM1, &kp DOWN)
SYM_THUMB_COMBO(RM2, &kp UP)
SYM_THUMB_COMBO(RM3, &kp RIGHT)
SYM_THUMB_COMBO(RM4, &kp ENTER)
SYM_THUMB_COMBO(RB0, &key_repeat) 
SYM_THUMB_COMBO(RB1, &kp BSPC)
SYM_THUMB_COMBO(RB2, &kp DEL)
SYM_THUMB_COMBO(RB3, &kp TAB)
// SYM_THUMB_COMBO(RB4, &kp CAPS)

// right thumb combos with left hand SYM layer 
#define SYM_THUMB_CROSS_COMBO(keypos, bindings) THUMB_COMBO(SYM, RH1, keypos, bindings, BASE)
SYM_THUMB_CROSS_COMBO(LT4, &kp TILDE)
SYM_THUMB_CROSS_COMBO(LT3, &kp PIPE)
SYM_THUMB_CROSS_COMBO(LT2, &kp UNDER)
SYM_THUMB_CROSS_COMBO(LT1, &kp LBKT)
SYM_THUMB_CROSS_COMBO(LT0, &kp RBKT)
SYM_THUMB_CROSS_COMBO(LM4, &kp GRAVE)
SYM_THUMB_CROSS_COMBO(LM3, &kp AMPS)
SYM_THUMB_CROSS_COMBO(LM2, &kp AT)
SYM_THUMB_CROSS_COMBO(LM1, &kp LPAR)
SYM_THUMB_CROSS_COMBO(LM0, &kp RPAR)
SYM_THUMB_CROSS_COMBO(LB4, &kp BSLH)
SYM_THUMB_CROSS_COMBO(LB3, &kp LT)
SYM_THUMB_CROSS_COMBO(LB2, &kp GT)
SYM_THUMB_CROSS_COMBO(LB1, &kp LBRC)
SYM_THUMB_CROSS_COMBO(LB0, &kp RBRC)

// left thumb combos with left hand NUM layer
#define NUM_THUMB_COMBO(keypos, bindings) THUMB_COMBO(NUM, LH1, keypos, bindings, BASE SYM)
NUM_THUMB_COMBO(LT4, &swapper)
NUM_THUMB_COMBO(LT3, &kp HASH)
NUM_THUMB_COMBO(LT2, &kp DLLR)
NUM_THUMB_COMBO(LT1, &kp PRCNT)
NUM_THUMB_COMBO(LT0, &kp CARET)
NUM_THUMB_COMBO(LM4, &sk LGUI)
NUM_THUMB_COMBO(LM3, &sk LALT)
NUM_THUMB_COMBO(LM2, &sk LCTRL)
NUM_THUMB_COMBO(LM1, &sk LSHFT)
NUM_THUMB_COMBO(LM0, &kp LGUI)
NUM_THUMB_COMBO(LB4, S_UNDO)
NUM_THUMB_COMBO(LB3, S_CUT)
NUM_THUMB_COMBO(LB2, S_COPY)
NUM_THUMB_COMBO(LB1, S_PASTE)
NUM_THUMB_COMBO(LB0, S_REDO)

// left thumb combos with right hand NUM layer
#define NUM_THUMB_CROSS_COMBO(keypos, bindings) THUMB_COMBO(NUM, LH1, keypos, bindings, BASE)
NUM_THUMB_CROSS_COMBO(RT0, &kp PLUS)
NUM_THUMB_CROSS_COMBO(RT1, &kp N7)
NUM_THUMB_CROSS_COMBO(RT2, &kp N8)
NUM_THUMB_CROSS_COMBO(RT3, &kp N9)
NUM_THUMB_CROSS_COMBO(RT4, &kp ASTRK)
NUM_THUMB_CROSS_COMBO(RM0, &kp N0)
NUM_THUMB_CROSS_COMBO(RM1, &kp N1)
NUM_THUMB_CROSS_COMBO(RM2, &kp N2)
NUM_THUMB_CROSS_COMBO(RM3, &kp N3)
NUM_THUMB_CROSS_COMBO(RM4, &kp EQUAL)
NUM_THUMB_CROSS_COMBO(RB0, &kp MINUS)
NUM_THUMB_CROSS_COMBO(RB1, &kp N4)
NUM_THUMB_CROSS_COMBO(RB2, &kp N5)
NUM_THUMB_CROSS_COMBO(RB3, &kp N6)
NUM_THUMB_CROSS_COMBO(RB4, &kp SLASH)

// combo_shift_left { 
//     key-positions = <RH1 LH1 LM2 RM0>; 
//     bindings = <&kp LC(LEFT)>; 
//     timeout-ms = <100>; 
//     partial-holds = <RH1 LH1 LM2>; 
//     layers = <BASE>; 
// };


