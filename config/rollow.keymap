// Copyright (c) 2022 The ZMK Contributors
// SPDX-License-Identifier: MIT

#include "../zmk-nodefree-config/helper.h"
#include "../zmk-nodefree-config/keypos_def/keypos_36keys.h"
#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/dynamic-macros.h>

#define XXX &none
#define TODO XXX
#define ___ &trans

#define BASE 0
#define NUM 1
#define SYM 2
#define UTIL 3
#define FUN 4
#define BT 5

#define S_UNDO &kp C_AC_UNDO
#define S_CUT &kp C_AC_CUT
#define S_COPY &kp C_AC_COPY
#define S_PASTE &kp C_AC_PASTE
#define S_REDO &kp C_AC_REDO

// TODO:
// - Harwdare:
//   - fix right encoder
//   - Fix left OLED
// - Conceptual:
//   - Consider HRM
//   - Consider mouse layer
//   - Investigate media keys (brightness, display toggle, music)
// - Minor:
//   - Triple tap num lock/caps lock
//   - Figure out a nice way to tap GUI
//   - Add delete word
//   - Caps word timeout
// - Enumerated actions:
//   - Consider better ways to activate BT
//   - Try to put dynamic macros on num
// - Workflow:
//   - Add text expansion macros
//   - Add programming bigrams
//   - Add bad SFBs to vertical combos, and put brackets on shift mod-morph, or transparent layer to specify combo
//   - Investigate symbol sfbs. 
// - ZMK:
//   - Make PR for partial release
//   - Document different SK behavior
//   - bug: sticky cancel releases mo layer

// what if re-add CANCEL on mo tap, but only on layer. Motivation, cancel num lock/caps word. Want to tap sym to cancel. 
// caps word invert on shift?
// caps kebab, double space ends word

// https://getreuer.info/posts/keyboards/select-word/index.html
// maybe patch tap dance to trigger on every tap

/* ------------------------ general config ----------------------- */
// smart-layer config
&caps_word {  
    /delete-property/ ignore-modifiers; // mods deactivate, requires PR #1451
    /delete-property/ ignore-numbers;
    continue-list = <BACKSPACE ENTER DELETE UNDERSCORE MINUS>;
};
&num_word { 
    layers = <NUM>; // requires PR #1441
    continue-list = <BACKSPACE ENTER DELETE UNDERSCORE MINUS PLUS ASTRK EQUAL FSLH DOT LPAR RPAR HASH DLLR PRCNT CARET LEFT RIGHT UP DOWN>;
};

// key-repeat config
&key_repeat {
    usage-pages = <HID_USAGE_KEY HID_USAGE_CONSUMER>; // repeat all keys
};

// default layer-tap config
&lt {  
    flavor = "balanced";
    tapping-term-ms = <200>;
};

ZMK_CONDITIONAL_LAYER(NUM SYM, UTIL)

/* ---------------------------- special behaviors --------------------------- */

// Alt+Tab swapper, requires PR #1366
ZMK_BEHAVIOR(swapper, tri_state,
    bindings = <&kt LALT>, <&kp TAB>, <&kt LALT>;
    ignored-key-positions = <LM1>; // shift-alt-tab 
)

// dynamci macros, requires PR #1351
#define PLAY_1 &dyn_macro_1 PLAY
#define REC_1 &dyn_macro_1 RECORD
ZMK_BEHAVIOR(dyn_macro_1, dynamic_macro, wait-ms = <10>;)
#define PLAY_2 &dyn_macro_2 PLAY
#define REC_2 &dyn_macro_2 RECORD
ZMK_BEHAVIOR(dyn_macro_2, dynamic_macro, wait-ms = <10>;)

/* --------------------------- sticky key behaviors -------------------------- */
// global config
&sk { // sticky-key
    release-after-ms = <3000>;  // release after timeout
    quick-release;              // no double capitalization when rolling keys
    lazy-activation;
};
&sl { // sticky-layer 
    release-after-ms = <500>;  // release after timeout
    // This is useful for enabling a layer and then pressing a bunch of sticky keys without leaving the layer. 
    // However, this breaks tapping sl+control+key because it does not exit the layer.
    // ignore-modifiers;
};

// all sticky keys are sticky when tapped, but momentary when held. 
// this allows for rolling layer keys, and accessing modifiers on base, while not getting in the way.
// this behavior is especially useful for use with a mouse because sticky odifiers don't linger
// requires: (custom sk release timing)
#define STICKY_TAP_MS 200

// tap: sticky-mod | hold: mod
#define SK(mod) &sk_mod mod mod
ZMK_BEHAVIOR(sk_mod, hold_tap,
    flavor = "balanced"; // balanced because we want to consider as tap when rolling
    tapping-term-ms = <STICKY_TAP_MS>; 
    bindings = <&kp>, <&sk>; 
    hold-while-undecided; // requires (pr and release patch)
)
#define SK_LGUI &sk_mod_no_lazy LGUI LGUI 
#define SK_LALT &sk_mod_no_lazy LALT LALT 
ZMK_BEHAVIOR(sk_no_lazy, sticky_key, 
    bindings = <&kp>;
    release-after-ms = <3000>;  // release after timeout
    quick-release;              // no double capitalization when rolling keys
    ignore-modifiers;
)
ZMK_BEHAVIOR(sk_mod_no_lazy, hold_tap,
    flavor = "balanced"; // balanced because we want to consider as tap when rolling
    tapping-term-ms = <STICKY_TAP_MS>; 
    bindings = <&kp>, <&sk_no_lazy>; 
    hold-while-undecided; // requires (pr and release patch)
)

// tap: sticky-shift | hold: shift | shift + tap / double-tap: caps-word 
#define SK_SHFT &sk_shft LSFT LSFT
ZMK_BEHAVIOR(sk_shft, hold_tap,
    flavor = "balanced"; 
    tapping-term-ms = <STICKY_TAP_MS>; 
    bindings = <&kp>, <&smrt_shft_morph>; 
    hold-while-undecided;
) 
ZMK_BEHAVIOR(smrt_shft_morph, mod_morph,
    mods = <(MOD_LSFT)>; // shift + tap: caps word
    bindings = <&sk LSFT>, <&caps_word>; 
) 

// tap: sticky-layer | hold: layer
#define SMRT_SYM &smrt_layer SYM SYM
#define SMRT_FUN &smrt_layer FUN FUN
ZMK_BEHAVIOR(smrt_layer, hold_tap,
    flavor = "hold-preferred"; // in most cases we want to avoid taps
    tapping-term-ms = <STICKY_TAP_MS>; 
    bindings = <&mo>, <&sl>; 
) 

// tap: sticky-num | hold: num | double-tap: num-word
#define SMRT_NUM &smrt_num NUM NUM
ZMK_BEHAVIOR(smrt_num, hold_tap,
    flavor = "hold-preferred"; 
    tapping-term-ms = <STICKY_TAP_MS>; 
    bindings = <&mo>, <&num_dance>; 
) 
ZMK_BEHAVIOR(num_dance, tap_dance,
    tapping-term-ms = <300>; 
    bindings = <&sl NUM>, <&num_word>; 
)

/* ------------------------------- mod-morphs ------------------------------- */
// tap: comma | shift + tap: semicolon 
ZMK_BEHAVIOR(comma_morph, mod_morph,
    mods = <(MOD_LSFT|MOD_RSFT)>;
    bindings = <&kp COMMA>, <&kp SEMICOLON>;
)
// tap: dot | shift + tap: colon 
ZMK_BEHAVIOR(dot_morph, mod_morph,
    bindings = <&kp DOT>, <&kp COLON>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
)
// tap: qmark | shift + tap: excl
ZMK_BEHAVIOR(qmark_morph, mod_morph,
    bindings = <&kp QMARK>, <&kp EXCL>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
)

// tap: space | shift + tap: dot -> space -> sticky shift
ZMK_BEHAVIOR(dot_spc, macro,
    wait-ms = <5>;
    tap-ms = <5>;
    bindings = <&dot_morph_cancel &kp SPACE &sk LSFT>;
)
ZMK_BEHAVIOR(dot_morph_cancel, mod_morph,
    bindings = <&kp DOT>, <&kp DOT>;
    mods = <(MOD_LSFT|MOD_RSFT)>;
)

/ {
    chosen {
        zmk,matrix_transform = &five_column_transform;
    };

    keymap {
        compatible = "zmk,keymap";
        default_layer {
            bindings = <
            &kp B   &kp L   &kp D   &kp W    &kp Z       &kp APOS   &kp F    &kp O         &kp U       &kp J 
            &kp N   &kp R   &kp T   &kp S    &kp G       &kp Y      &kp H    &kp A         &kp E       &kp I 
            &kp Q   &kp X   &kp M   &kp C    &kp V       &kp K      &kp P    &comma_morph  &dot_morph  &qmark_morph
                    &kp C_MUTE      SMRT_NUM SK_SHFT     &kp SPACE  SMRT_SYM XXX 
            >;
            sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp UP DOWN>;
        };
        num_layer {
            bindings = <
            &swapper  &kp HASH  &kp DLLR   &kp PRCNT  &kp CARET   &kp PLUS  &kp N6   &kp N7  &kp N8  &kp ASTRK 
            SK_LGUI   SK_LALT   SK(LCTL)   SK(LSFT)   SMRT_FUN    &kp EQUAL &kp N0   &kp N1  &kp N2  &kp N9 
            S_UNDO    S_CUT     S_COPY     S_PASTE    S_REDO      &kp MINUS &kp N3   &kp N4  &kp N5  &lt BT FSLH 
                                XXX        ___        &kp SPACE   &kp SPACE ___      XXX 
            >;
            sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp UP DOWN>;
        };
        sym_layer {
            bindings = <
            &kp TILDE  &kp PIPE  &kp UNDER  &kp LBKT  &kp RBKT   &kp HOME    &kp PG_DN  &kp PG_UP  &kp END    &kp ESC 
            &kp GRAVE  &kp AMPS  &kp AT     &kp LPAR  &kp RPAR   &kp LEFT    &kp DOWN   &kp UP     &kp RIGHT  &kp ENTER 
            &kp BSLH   &kp LT    &kp GT     &kp LBRC  &kp RBRC   &key_repeat &kp BSPC   &kp DEL    &kp TAB    &kp CAPS 
                                 XXX        ___       ___        ___         ___        XXX 
            >;
            sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp UP DOWN>;
        };
 
        util_layer {
            bindings = <
            &bootloader REC_1     PLAY_1     PLAY_2    REC_2       &kp HOME     &kp PG_DN  &kp PG_UP   &kp END    &kp ESC 
            SK_LGUI     SK_LALT   SK(LCTL)   SK(LSFT)  &kp PSCRN   &kp LEFT     &kp DOWN   &kp UP      &kp RIGHT  &kp ENTER 
            S_UNDO      S_CUT     S_COPY     S_PASTE   S_REDO      &key_repeat  &kp BSPC   &kp DEL     &kp TAB    &kp CAPS 
                                  XXX        ___       ___         ___          ___        XXX 
            >;
            sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp UP DOWN>;
        };

        fun_layer {
            bindings = <
            ___       ___       ___        ___        ___    &kp F12  &kp F6      &kp F7  &kp F8  ___ 
            SK_LGUI   SK_LALT   SK(LCTL)   SK(LSFT)   ___    &kp F11  &kp INSERT  &kp F1  &kp F2  &kp F9
            ___       ___       ___        ___        ___    &kp F10  &kp F3      &kp F4  &kp F5  ___
                                ___        ___        ___    ___      ___         ___ 
            >;
            sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp UP DOWN>;
        };

        bt_layer {
            bindings = <
            ___  ___  ___  ___  ___   &bt BT_NXT  ___           ___           ___           ___ 
            ___  ___  ___  ___  ___   &bt BT_CLR  &bt BT_SEL 0  &bt BT_SEL 1  &bt BT_SEL 2  ___ 
            ___  ___  ___  ___  ___   &bt BT_PRV  &bt BT_SEL 3  &bt BT_SEL 4  &bt BT_SEL 5  ___
                      ___  ___  ___   ___         ___           ___ 
            >;
            sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp UP DOWN>;
        };
    };
};
    
/* --------------------------------- combos --------------------------------- */
// ╭─────────────────────┬─────────────────────╮
// │ LT4 LT3 LT2 LT1 LT0 │ RT0 RT1 RT2 RT3 RT4 │
// │ LM4 LM3 LM2 LM1 LM0 │ RM0 RM1 RM2 RM3 RM4 │
// │ LB4 LB3 LB2 LB1 LB0 │ RB0 RB1 RB2 RB3 RB4 │
// ╰───────╮ LH2 LH1 LH0 │ RH0 RH1 RH2 ╭───────╯
//         ╰─────────────┴─────────────╯
// use global-quick-tap-ms for combos (requires PR 1387)
#undef COMBO_HOOK
#define COMBO_HOOK global-quick-tap-ms = <50>;
// combos on every layer
#define GLOBAL_COMBO(name, keypos, bindings) ZMK_COMBO(name, bindings, keypos, ALL, 50)
GLOBAL_COMBO(esc, LT3 LT2, &kp ESC)
GLOBAL_COMBO(tab, LT2 LT1, &kp TAB)
GLOBAL_COMBO(rep, LB3 LB2, &key_repeat)
GLOBAL_COMBO(ent, LB2 LB1, &kp ENTER)
GLOBAL_COMBO(word, RT1 RT2, &caps_word)
GLOBAL_COMBO(bksp, RB1 RB2, &kp BSPC)
GLOBAL_COMBO(del, RB2 RB3, &kp DEL)
GLOBAL_COMBO(numl, RB3 RB4, &num_word)

GLOBAL_COMBO(lbkt, LT3 LM3, &kp LBKT)
GLOBAL_COMBO(rbkt, RT3 RM3, &kp RBKT)
GLOBAL_COMBO(lpar, LT2 LM2, &kp LPAR)
GLOBAL_COMBO(rpar, RT2 RM2, &kp RPAR)
GLOBAL_COMBO(lbrc, LT1 LM1, &kp LBRC)
GLOBAL_COMBO(rbrc, RT1 RM1, &kp RBRC)
GLOBAL_COMBO(lt, LT0 LM0, &kp LT)
GLOBAL_COMBO(gt, RT0 RM0, &kp GT)

GLOBAL_COMBO(dot_spc, LH0 RH0, &dot_spc)

// combos on the numpad
#define NUM_COMBO(name, keypos, bindings) ZMK_COMBO(name, bindings, keypos, NUM, 40)
NUM_COMBO(dot, RM0 RM1, &kp DOT)

// thumb combos are a feature that I designed to make it faster to type keys on the layers
// it allows you to mash the thumb mo key and the key on the layer together at the same time
// it relies on a patch I made to zmk which allows partial-holds when releasing the key while holding the thumb
// thumb combos are implemented using a few hacks that solve all edge cases
// the macro is used to enable the layer while the combo is held so that other keys on the layer can be used
#define THUMB_COMBO_GENERAL(thumb_behavior, thumb_param, thumb, combo_layers, keypos, combo_bindings) \
    ZMK_BEHAVIOR(macro_thumb_##thumb_param##_##thumb##_##keypos, macro, \
        wait-ms = <0>; \
        tap-ms = <0>; \
        bindings \
            = <&macro_press thumb_behavior thumb_param> \
            , <&macro_press combo_bindings> \
            , <&macro_pause_for_release> \
            , <&macro_release combo_bindings> \
            , <&macro_release thumb_behavior thumb_param> \
            ; \
    ) \
    / { \
        combos { \
            compatible = "zmk,combos"; \
            combo_thumb_##thumb_param##_##thumb##_##keypos { \
                timeout-ms = <40>; \
                layers = <combo_layers>; \
                key-positions = <thumb keypos>; \
                bindings = <&macro_thumb_##thumb_param##_##thumb##_##keypos>, <&partial_hold_position thumb thumb_behavior thumb_param>; \
                slow-release;  \
                slow-release-positions = <keypos>; \
                COMBO_HOOK \
            }; \
        }; \
    };
#define THUMB_LAYER_COMBO(thumb_param, thumb, combo_layers, keypos, combo_bindings) THUMB_COMBO_GENERAL(&mo, thumb_param, thumb, combo_layers, keypos, combo_bindings)

// right thumb combos with right hand SYM layer
#define SYM_THUMB_COMBO(keypos, bindings) THUMB_LAYER_COMBO(SYM, RH1, BASE NUM, keypos, bindings)
SYM_THUMB_COMBO(RT0, &kp HOME)
SYM_THUMB_COMBO(RT1, &kp PG_DN)
SYM_THUMB_COMBO(RT2, &kp PG_UP)
SYM_THUMB_COMBO(RT3, &kp END)
SYM_THUMB_COMBO(RT4, &kp ESC)
SYM_THUMB_COMBO(RM0, &kp LEFT)
SYM_THUMB_COMBO(RM1, &kp DOWN)
SYM_THUMB_COMBO(RM2, &kp UP)
SYM_THUMB_COMBO(RM3, &kp RIGHT)
SYM_THUMB_COMBO(RM4, &kp ENTER)
SYM_THUMB_COMBO(RB0, &key_repeat) 
SYM_THUMB_COMBO(RB1, &kp BSPC)
SYM_THUMB_COMBO(RB2, &kp DEL)
SYM_THUMB_COMBO(RB3, &kp TAB)
// SYM_THUMB_COMBO(RB4, &kp CAPS)

// right thumb combos with left hand SYM layer 
#define SYM_THUMB_CROSS_COMBO(keypos, bindings) THUMB_LAYER_COMBO(SYM, RH1, BASE, keypos, bindings)
SYM_THUMB_CROSS_COMBO(LT4, &kp TILDE)
SYM_THUMB_CROSS_COMBO(LT3, &kp PIPE)
SYM_THUMB_CROSS_COMBO(LT2, &kp UNDER)
SYM_THUMB_CROSS_COMBO(LT1, &kp LBKT)
SYM_THUMB_CROSS_COMBO(LT0, &kp RBKT)
SYM_THUMB_CROSS_COMBO(LM4, &kp GRAVE)
SYM_THUMB_CROSS_COMBO(LM3, &kp AMPS)
SYM_THUMB_CROSS_COMBO(LM2, &kp AT)
SYM_THUMB_CROSS_COMBO(LM1, &kp LPAR)
SYM_THUMB_CROSS_COMBO(LM0, &kp RPAR)
SYM_THUMB_CROSS_COMBO(LB4, &kp BSLH)
SYM_THUMB_CROSS_COMBO(LB3, &kp LT)
SYM_THUMB_CROSS_COMBO(LB2, &kp GT)
SYM_THUMB_CROSS_COMBO(LB1, &kp LBRC)
SYM_THUMB_CROSS_COMBO(LB0, &kp RBRC)

// left thumb combos with left hand NUM layer
#define NUM_THUMB_COMBO(keypos, bindings) THUMB_LAYER_COMBO(NUM, LH1, BASE SYM, keypos, bindings)
NUM_THUMB_COMBO(LT4, &swapper)
NUM_THUMB_COMBO(LT3, &kp HASH)
NUM_THUMB_COMBO(LT2, &kp DLLR)
NUM_THUMB_COMBO(LT1, &kp PRCNT)
NUM_THUMB_COMBO(LT0, &kp CARET)
NUM_THUMB_COMBO(LM4, SK_LGUI)
NUM_THUMB_COMBO(LM3, SK_LALT)
NUM_THUMB_COMBO(LM2, SK(LCTL) )
NUM_THUMB_COMBO(LM1, SK(LSFT))
NUM_THUMB_COMBO(LM0, SMRT_FUN)
NUM_THUMB_COMBO(LB4, S_UNDO)
NUM_THUMB_COMBO(LB3, S_CUT)
NUM_THUMB_COMBO(LB2, S_COPY)
NUM_THUMB_COMBO(LB1, S_PASTE)
NUM_THUMB_COMBO(LB0, S_REDO)

// left thumb combos with right hand NUM layer
#define NUM_THUMB_CROSS_COMBO(keypos, bindings) THUMB_LAYER_COMBO(NUM, LH1, BASE, keypos, bindings)
NUM_THUMB_CROSS_COMBO(RT0, &kp PLUS)
NUM_THUMB_CROSS_COMBO(RT1, &kp N6)
NUM_THUMB_CROSS_COMBO(RT2, &kp N7)
NUM_THUMB_CROSS_COMBO(RT3, &kp N8)
NUM_THUMB_CROSS_COMBO(RT4, &kp ASTRK)
NUM_THUMB_CROSS_COMBO(RM0, &kp EQUAL)
NUM_THUMB_CROSS_COMBO(RM1, &kp N0)
NUM_THUMB_CROSS_COMBO(RM2, &kp N1)
NUM_THUMB_CROSS_COMBO(RM3, &kp N2)
NUM_THUMB_CROSS_COMBO(RM4, &kp N9)
NUM_THUMB_CROSS_COMBO(RB0, &kp MINUS)
NUM_THUMB_CROSS_COMBO(RB1, &kp N3)
NUM_THUMB_CROSS_COMBO(RB2, &kp N4)
NUM_THUMB_CROSS_COMBO(RB3, &kp N5)
NUM_THUMB_CROSS_COMBO(RB4, &kp SLASH)

#define SHFT_THUMB_COMBO(keypos, bindings) THUMB_COMBO_GENERAL(&kp, LSFT, LH0, BASE, keypos, bindings)
SHFT_THUMB_COMBO(LT4, &kp B)
SHFT_THUMB_COMBO(LT3, &kp L)
SHFT_THUMB_COMBO(LT2, &kp D)
SHFT_THUMB_COMBO(LT1, &kp W)
SHFT_THUMB_COMBO(LT0, &kp Z)
SHFT_THUMB_COMBO(LM4, &kp N)
SHFT_THUMB_COMBO(LM3, &kp R)
SHFT_THUMB_COMBO(LM2, &kp T)
SHFT_THUMB_COMBO(LM1, &kp S)
SHFT_THUMB_COMBO(LM0, &kp G)
SHFT_THUMB_COMBO(LB4, &kp Q)
SHFT_THUMB_COMBO(LB3, &kp X)
SHFT_THUMB_COMBO(LB2, &kp M)
SHFT_THUMB_COMBO(LB1, &kp C)
SHFT_THUMB_COMBO(LB0, &kp V)

SHFT_THUMB_COMBO(RT0, &kp APOS)
SHFT_THUMB_COMBO(RT1, &kp F)
SHFT_THUMB_COMBO(RT2, &kp O)
SHFT_THUMB_COMBO(RT3, &kp U)
SHFT_THUMB_COMBO(RT4, &kp J)
SHFT_THUMB_COMBO(RM0, &kp Y)
SHFT_THUMB_COMBO(RM1, &kp H)
SHFT_THUMB_COMBO(RM2, &kp A)
SHFT_THUMB_COMBO(RM3, &kp E)
SHFT_THUMB_COMBO(RM4, &kp I)
SHFT_THUMB_COMBO(RB0, &kp K)
SHFT_THUMB_COMBO(RB1, &kp P)
SHFT_THUMB_COMBO(RB2, &comma_morph)
SHFT_THUMB_COMBO(RB3, &dot_morph)
SHFT_THUMB_COMBO(RB4, &qmark_morph)


// combo_shift_left { 
//     key-positions = <RH1 LH1 LM2 RM0>; 
//     bindings = <&kp LC(LEFT)>; 
//     timeout-ms = <100>; 
//     partial-holds = <RH1 LH1 LM2>; 
//     layers = <BASE>; 
// };


